/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include "jvips_VipsNative.h"
#include "jvips.h"
#include <vips/vips.h>
#include <map>
#include <vector>
#include <iostream>
#include <functional>
#include <ffi.h>
#include <memory>
#include <optional>
#include <fmt/core.h>

using namespace std;

jclass ByteBuffer_class;
jclass bufferClass;
jclass String_class;

jclass VipsImage_class;


jfieldID byteBufferField;






Primitive javaInteger;
Primitive javaDouble;
Primitive javaLong;
Primitive javaFloat;
Primitive javaShort;
Primitive javaByte;
Primitive javaChar;
Primitive javaBoolean;


JavaVM *jvm;
jint version;

jclass vipsContext;
jmethodID cleanUpMethod;

jclass loggerClass;

// 0 - OFF
// 1 - ERROR
// 2 - WARNING
// 3 - INFO
// 4 - DEBUG
// 5 - TRACE
jint loglevel;



Logger logger = {};



#define LOG_TRACE 5
#define LOG_DEBUG 4
#define LOG_INFO 3
#define LOG_WARNING 2
#define LOG_ERROR 0

#define ASSIGN_CLASS_GLOBAL(__name, __assignment){ \
    jclass clazz = env->FindClass(__name); \
    __assignment = (jclass) env->NewGlobalRef(clazz); \
}

jclass doubleArrayClass;
jclass intArrayClass;
jclass vipsAreaClass;
jclass vipsBlobClass;


#define BOX(__struct, __name, __primitiveSignature, __gtype) { \
   jclass clazz = env->FindClass("java/lang/" __name); \
   clazz = (jclass) env->NewGlobalRef(clazz);         \
   __struct = {clazz,                     \
               env->GetFieldID(clazz, "value", __primitiveSignature), \
               env->GetStaticMethodID(clazz, "valueOf", "(" __primitiveSignature ")Ljava/lang/" __name ";"), \
              __gtype \
   };\
}

#define SET_OFFSET(__name, __field){ \
    id = env->GetStaticFieldID(VipsImage_class, __name, "I");\
    env->SetStaticIntField(VipsImage_class, id, (jint) offsetof(VipsImage, __field));\
}

#define SET_OFFSET_AREA(__name, __field){ \
    id = env->GetStaticFieldID(vipsAreaClass, __name, "I");\
    env->SetStaticIntField(vipsAreaClass, id, (jint) offsetof(VipsArea, __field));\
}

#define SET_OFFSET_BLOB(__name, __field){ \
    id = env->GetStaticFieldID(vipsBlobClass, __name, "I");\
    env->SetStaticIntField(vipsBlobClass, id, (jint) offsetof(VipsBlob, __field));\
}

// Is client using sun.misc.Unsafe to read arbitrary memory
bool unsafe;



/**
 * JNI_OnLoad throwing errors, mismatched VM
 * @param env
 * @param clzz
 * @param str
 * @param _unsafe Is client using sun.misc.Unsafe to read arbitrary memory
 */
JNIEXPORT void JNICALL Java_jvips_VipsNative_init
        (JNIEnv *env, jclass clzz, jstring str, jobject log, jint level, jboolean _unsafe) {

    // Is client using sun.misc.Unsafe to read arbitrary memory
    unsafe = _unsafe;
    version = env->GetVersion();
    logger.instance = log;
    logger.level = level;

    VIPS_INIT("start");
    ASSIGN_CLASS_GLOBAL("com/pss/jvips/jni/JniVipsImage", VipsImage_class);
    ASSIGN_CLASS_GLOBAL("[D", doubleArrayClass);
    ASSIGN_CLASS_GLOBAL("[I", intArrayClass);
    ASSIGN_CLASS_GLOBAL("com/pss/jvips/jni/JniVipsArea", vipsAreaClass);
    ASSIGN_CLASS_GLOBAL("com/pss/jvips/jni/JniVipsBlob", vipsBlobClass);


    jfieldID id;

    SET_OFFSET_BLOB("offsetArea", area)

    SET_OFFSET_AREA("offsetLength", length)
    SET_OFFSET_AREA("offsetN", n)
    SET_OFFSET_AREA("offsetType", type)
    SET_OFFSET_AREA("offsetSizeOfType", sizeof_type)



    SET_OFFSET("offsetXsize", Xsize)
    SET_OFFSET("offsetYsize", Ysize)
    SET_OFFSET("offsetBands", Bands)
    SET_OFFSET("offsetBandFmt", BandFmt)
    SET_OFFSET("offsetCoding", Coding)
    SET_OFFSET("offsetType", Type)
    SET_OFFSET("offsetXres", Xres)
    SET_OFFSET("offsetYres", Yres)
    SET_OFFSET("offsetXoffset", Xoffset)
    SET_OFFSET("offsetYoffset", Yoffset)
    SET_OFFSET("offsetLength", Length)
    SET_OFFSET("offsetCompression", Compression)
    SET_OFFSET("offsetLevel", Level)
    SET_OFFSET("offsetBbits", Bbits)


    BOX(javaInteger, "Integer", "I", G_TYPE_INT)
    BOX(javaByte, "Byte", "B", G_TYPE_CHAR)
    BOX(javaLong, "Long", "J", G_TYPE_LONG)
    BOX(javaBoolean, "Boolean", "Z", G_TYPE_BOOLEAN)
    BOX(javaFloat, "Float", "F", G_TYPE_FLOAT)
    BOX(javaDouble, "Double", "D", G_TYPE_DOUBLE)
    BOX(javaShort, "Short", "S", G_TYPE_INT)
    BOX(javaChar, "Character", "C", G_TYPE_CHAR)

    ASSIGN_CLASS_GLOBAL("java/nio/ByteBuffer", ByteBuffer_class);



    ASSIGN_CLASS_GLOBAL("java/lang/String", String_class);
    ASSIGN_CLASS_GLOBAL("org/slf4j/Logger", logger.clazz);

    logger.info = env->GetMethodID(logger.clazz, "info", "(Ljava/lang/String;)V");
    logger.warning = env->GetMethodID(logger.clazz, "warn", "(Ljava/lang/String;)V");
    logger.debug = env->GetMethodID(logger.clazz, "debug", "(Ljava/lang/String;)V");
    logger.error = env->GetMethodID(logger.clazz, "error", "(Ljava/lang/String;)V");
    logger.trace = env->GetMethodID(logger.clazz, "trace", "(Ljava/lang/String;)V");

#if JAVA_LOG
    if(logger.level > LOG_ERROR){
            jstring jmessage = env->NewStringUTF("Initialized libvips");
            env->CallVoidMethod(logger.instance, logger.info, jmessage);
        }
#endif
}

#define REQUIRE_NOT_NULL(__value) {\
    if(env->IsSameObject(__value, nullptr) == JNI_TRUE){\
        return -2;\
    }\
}                                  \

#define REQUIRE_NOT_NULL_WITH_MESSAGE(__value, __message) {\
    if(env->IsSameObject(__value, nullptr) == JNI_TRUE){\
        return handleError(env, __message, messages);\
    }\
}\



#define NOT_NULL_CHECK(__value) env->IsSameObject(__value, nullptr) != JNI_TRUE


#define IS_TYPE(__value, __clazz) env->IsInstanceOf(__value, __clazz)


#define GET_LONG(__value) env->GetLongField(__value, javaLong.value)
#define GET_BYTE(__value) env->GetByteField(__value, javaByte.value)
#define GET_DOUBLE(__value) env->GetDoubleField(__value, javaDouble.value)
#define GET_FLOAT(__value) env->GetFloatField(__value, javaFloat.value)
#define GET_BOOLEAN(__value) env->GetBooleanField(__value, javaBoolean.value)
#define GET_INT(__value) env->GetIntField(__value, javaInteger.value)


void cleanupJavaRefs(VipsObject *object, const long *pid) {
    JNIEnv *env;
    JavaVMAttachArgs args;
    args.version = version;
    args.group = nullptr;
    args.name = nullptr;
    if (jvm->AttachCurrentThread((void **) &env, &args)) {
       // long *pid = (long *) g_object_get_data(&object->parent_instance, "image-id");
        if (pid != nullptr) {
            auto javalong = (jlong) *pid;
            env->CallStaticVoidMethod(vipsContext, cleanUpMethod, javalong);
            delete pid;
        }
    }
}

string getString0(JNIEnv *env, jstring str){
    if(str != nullptr){
        const char *chars = env->GetStringUTFChars(str, 0);
        auto value = string(chars);
        env->ReleaseStringUTFChars(str, chars);
        return value;
    }
    throw std::invalid_argument("Null string passed to getString");
}

bool getString(JNIEnv *env, jstring string, std::string &copy) {
    if (string != nullptr) {
        const char *chars = env->GetStringUTFChars(string, 0);
        copy.append(chars);
        env->ReleaseStringUTFChars(string, chars);
        return false;
    }
    return true;
}

bool getStringFromObject(JNIEnv *env, jobject obj, string &copy) {
    if (IS_TYPE(obj, String_class)) {
        jstring value = (jstring) obj;
        return getString(env, value, copy);
    }
    return true;
}


JNIEXPORT jobject JNICALL Java_jvips_VipsNative_newImageFromFile0
        (JNIEnv *env, jclass clazz, jstring filename, jlong id) {
    string file;
    if (getString(env, filename, file)) {
        return nullptr;
    }
    VipsImage *in;
    if ((in = vips_image_new_from_file(file.c_str(), NULL))) {

        if(unsafe) {
            jobject o = env->CallStaticObjectMethod(javaLong.clazz, javaLong.factory, (jlong) (void *) in);
           return o;
        } else {
            jobject  bb = env->NewDirectByteBuffer((void *) in, sizeof(VipsImage));
            return bb;
        }
    }
    return nullptr;;
}

/**
 * Every operation must have at least 3 arguments and length divisible by 3
 * @param length
 * @return
 */
bool checkArgLength(const jint *length) {
    return  (*length % 3) == 0;
}

std::optional<VipsImage*> getPointy(JNIEnv *env, Argument &argument) {
    if (unsafe && IS_TYPE(argument.value, javaLong.clazz)) {
        jlong p = GET_LONG(argument.value);
        return (VipsImage *) (void *) p;
    } else if(IS_TYPE(argument.value, ByteBuffer_class)) {
        return (VipsImage *) (void *) env->GetDirectBufferAddress(argument.value);
    }
    return nullptr;
}

bool getParameter(JNIEnv *env, Argument &argument, jobjectArray params, int index, jobjectArray messages) {
    jobject param = env->GetObjectArrayElement(params, index);

    string paramName;
    if (getStringFromObject(env, param, paramName)) {
        return false;
    }
    jobject flags = env->GetObjectArrayElement(params, index + 1);
    if (!IS_TYPE(flags, javaLong.clazz)) {
        return false;
    }

    jlong lflags = env->GetLongField(flags, javaLong.value);
    argument.name = make_unique<string>(paramName);
    argument.type = lflags;
    // @Nullable
    jobject value = env->GetObjectArrayElement(params, index + 2);
    argument.value = value;

    bool valueNotNull = NOT_NULL_CHECK(value);
    argument.valueNotNull = valueNotNull;
    return true;
}


jlong handleError(JNIEnv *env, const char *message, jobjectArray &messages) {
    auto messageLength = env->GetArrayLength(messages);
    if (messageLength < 1) {
        return -2;
    }
    jstring jmessage = env->NewStringUTF(message);
    env->SetObjectArrayElement(messages, 0, jmessage);
    return -1;
}


jlong handleError(JNIEnv *env, string &message, jobjectArray &messages) {
    auto messageLength = env->GetArrayLength(messages);
    if (messageLength < 1) {
        return -2;
    }
    jstring jmessage = env->NewStringUTF(message.c_str());
    env->SetObjectArrayElement(messages, 0, jmessage);
    return -1;
}



JNIEXPORT jlong JNICALL Java_jvips_VipsNative_callNative
        (JNIEnv *env, jclass clazz, jstring operation, jobjectArray in,
         jobjectArray out, jobjectArray messages) {

#if JAVA_LOG
    if(logger.level > LOG_DEBUG){
        string cppOperationName;
        if(!getString(env, operation, cppOperationName)){
            string message = "Entering native method: " + cppOperationName;
            jstring jmessage = env->NewStringUTF(message.c_str());
            env->CallVoidMethod(logger.instance, logger.debug, jmessage);
        }
    }
#endif

    // returns if null
    REQUIRE_NOT_NULL(messages)
    auto messageLength = env->GetArrayLength(messages);
    if (messageLength < 1) {
#if JAVA_LOG
        if(logger.level > LOG_ERROR){
            jstring jmessage = env->NewStringUTF("Message array was null or empty");
            env->CallVoidMethod(logger.instance, logger.error, jmessage);
        }
#endif
        return -2;
    }

    // returns if null
    REQUIRE_NOT_NULL_WITH_MESSAGE(operation, "Operation was null")

    // returns if null
    REQUIRE_NOT_NULL_WITH_MESSAGE(in, "In Parameter array was null")

    // returns if null
    REQUIRE_NOT_NULL_WITH_MESSAGE(out, "Out Parameter array was null")


    std::string operationName;
    if (getString(env, operation, operationName)) {
        return handleError(env, "Failed to get operation name string", messages);
    }

    auto inLength = env->GetArrayLength(in);
    auto outLength = env->GetArrayLength(out);

    if (!checkArgLength(&inLength)) {
        string s = fmt::format("In array was 0 length or not Divisible by 3 length: {}", inLength);
        return handleError(env, s, messages);
    }

    if (!checkArgLength(&outLength)) {
        string s = fmt::format("Out array was 0 length or not Divisible by 3 length: {}", outLength);
        return handleError(env, s, messages);
    }

    VipsOperation *op;
    VipsOperation *new_op;
    GValue gvalue = {0};

    op = vips_operation_new(operationName.c_str());

#if JAVA_LOG
    if(logger.level > LOG_ERROR){
        string message = fmt::format("Starting operation: {}", operationName);
        jstring jmessage = env->NewStringUTF(message.c_str());
        env->CallVoidMethod(logger.instance, logger.info, jmessage);
    }
#endif

    for (int i = 0; i < inLength; i += 3) {
        Argument argument = {};
        if (!getParameter(env, argument, in, i, messages)) {
            vips_object_unref_outputs(VIPS_OBJECT(op));
            g_object_unref(op);
            string s = fmt::format("Failed to parse in array at index:  {}", i);
            return handleError(env, s.c_str(), messages);
        }
        if (argument.valueNotNull) {
            switch (argument.type) {
                case jvips_VipsNative_STRING: {
                    if (IS_TYPE(argument.value, String_class)) {
                        g_value_init(&gvalue, G_TYPE_STRING);
                        std::string paramValue;
                        if (getStringFromObject(env, argument.value, paramValue)) {
                            vips_object_unref_outputs(VIPS_OBJECT(op));
                            g_object_unref(op);

                            string message = fmt::format("Failed to parse string value array at index: {} for argument: {}",
                                                         (i + 2), *argument.name);
                            return handleError(env, message, messages);
                        }
                        g_value_set_string(&gvalue, paramValue.c_str());
                        g_object_set_property(G_OBJECT(op), argument.name->c_str(), &gvalue);
                        g_value_unset(&gvalue);
                    } else {
                        if(NOT_NULL_CHECK(argument.value)){
                            string message = fmt::format("Argument at index: {} for argument name: {} was null",
                                                         (i + 2), *argument.name);
                            return handleError(env, message, messages);
                        } else {
                            string message = fmt::format("Argument at index: {} for argument name: {} is not a java.lang.String",
                                                         (i + 2), *argument.name);
                            return handleError(env, message, messages);
                        }

                    }
                    break;
                }
                case jvips_VipsNative_LONG: {
                    if (IS_TYPE(argument.value, javaLong.clazz)) {
                        jlong v = GET_LONG(argument.value);
                        g_value_init(&gvalue, G_TYPE_LONG);
                        g_value_set_long(&gvalue, v);
                        g_object_set_property(G_OBJECT(op), argument.name->c_str(), &gvalue);
                        g_value_unset(&gvalue);
                    }
                    break;
                }
                case jvips_VipsNative_BOOLEAN: {
                    if (IS_TYPE(argument.value, javaBoolean.clazz)) {
                        jboolean v = GET_BOOLEAN(argument.value);
                        g_value_init(&gvalue, G_TYPE_BOOLEAN);
                        g_value_set_boolean(&gvalue, v);
                        g_object_set_property(G_OBJECT(op), argument.name->c_str(), &gvalue);
                        g_value_unset(&gvalue);
                    }
                    break;
                }
                case jvips_VipsNative_DOUBLE: {
                    if (IS_TYPE(argument.value, javaDouble.clazz)) {
                        jdouble v = GET_DOUBLE(argument.value);
                        g_value_init(&gvalue, G_TYPE_DOUBLE);
                        g_value_set_double(&gvalue, v);
                        g_object_set_property(G_OBJECT(op), argument.name->c_str(), &gvalue);
                        g_value_unset(&gvalue);
                    }
                    break;
                }
                case jvips_VipsNative_BYTE: {
                    if (IS_TYPE(argument.value, javaByte.clazz)) {
                        jbyte v = GET_BYTE(argument.value);
                        g_value_init(&gvalue, G_TYPE_CHAR);
                        g_value_set_schar(&gvalue, v);
                        g_object_set_property(G_OBJECT(op), argument.name->c_str(), &gvalue);
                        g_value_unset(&gvalue);
                    }
                    break;
                }
                case jvips_VipsNative_INT: {
                    if (IS_TYPE(argument.value, javaInteger.clazz)) {

                        jint v = GET_INT(argument.value);
                        g_value_init(&gvalue, G_TYPE_INT);
                        g_value_set_int(&gvalue, v);
                        g_object_set_property(G_OBJECT(op), argument.name->c_str(), &gvalue);
                        g_value_unset(&gvalue);
                    }
                    break;
                }
                case jvips_VipsNative_ENUM: {
                    if (IS_TYPE(argument.value, javaInteger.clazz)) {

                        jint v = GET_INT(argument.value);
                        g_value_init(&gvalue, G_TYPE_INT);
                        g_value_set_enum(&gvalue, v);
                        g_object_set_property(G_OBJECT(op), argument.name->c_str(), &gvalue);
                        g_value_unset(&gvalue);
                    }
                    break;
                }

                case jvips_VipsNative_BYTE_BUFFER: {
                    if (IS_TYPE(argument.value, ByteBuffer_class)) {
                        // How do I deal with a bb of doubles?? what is the length?
                        void *ptr = env->GetDirectBufferAddress(argument.value);
                        g_value_init(&gvalue, G_TYPE_POINTER);
                        g_value_set_pointer(&gvalue, ptr);
                        g_object_set_property(G_OBJECT(op), argument.name->c_str(), &gvalue);
                        g_value_unset(&gvalue);
                    }
                    break;
                }

                case jvips_VipsNative_IMAGE: {
                    auto optr = getPointy(env, argument);
                    if (optr.has_value()) {
                        auto ptr = optr.value();
                        if (!VIPS_IS_IMAGE(ptr)) {
                            vips_object_unref_outputs(VIPS_OBJECT(op));
                            g_object_unref(op);

                            string s = fmt::format("Pointer address at {} at index: {} for argument: {} was not a VipsImage",
                                                   (uint64_t) (void *) ptr, (i + 2), *argument.name);
                            return handleError(env, s.c_str(), messages);
                        }
                        g_value_init(&gvalue, VIPS_TYPE_IMAGE);
                        g_value_set_object(&gvalue, ptr);
                        g_object_set_property(G_OBJECT(op), argument.name->c_str(), &gvalue);
                        g_value_unset(&gvalue);
                    }
                    break;
                }

                case jvips_VipsNative_IMAGE_ARRAY: {

                    break;
                }
            }
        }
    }


        std::cerr << "Finished Setting Params\n";

        if (!(new_op = vips_cache_operation_build(op))) {
            string error = vips_error_buffer_copy();
            g_object_unref(op);
            return handleError(env, error.c_str(), messages);
        }
        g_object_unref(op);
        op = new_op;

        for (int i = 0; i < outLength; i += 3) {
            Argument argument = {};
            if (!getParameter(env, argument, out, i, messages)) {
                string s = "Failed to parse in array at index:  " + to_string(i);
                vips_object_unref_outputs(VIPS_OBJECT(op));
                g_object_unref(op);
                return handleError(env, s.c_str(), messages);
            }
            switch (argument.type) {
                case jvips_VipsNative_IMAGE: {
                    jlong id = GET_LONG(argument.value); // Get the id stored in the out array
                    VipsImage *vout;
                    g_value_init(&gvalue, VIPS_TYPE_IMAGE);
                    g_object_get_property(G_OBJECT(op), argument.name->c_str(), &gvalue);
                    vout = VIPS_IMAGE(g_value_get_object(&gvalue));
                    g_value_unset(&gvalue);
                    void* outaddress =  (void *) vout;
                    if(unsafe) {
                        jobject o = env->CallStaticObjectMethod(javaLong.clazz, javaLong.factory, (jlong) outaddress);
                        env->SetObjectArrayElement(out, i + 2, o);
                    } else {
                        jobject  bb = env->NewDirectByteBuffer(outaddress, sizeof(VipsImage));
                        env->SetObjectArrayElement(out, i + 2, bb);
                    }
                    long *j = new long(id);
                    g_signal_connect(out, "preclose", G_CALLBACK(cleanupJavaRefs), NULL);
                    g_object_set_data(&vout->parent_instance.parent_instance, "image-id", j);
                    break;
                }
                case jvips_VipsNative_BLOB: {
                    jlong id = GET_LONG(argument.value); // Get the id stored in the out array
                    VipsBlob *vout;
                    g_value_init(&gvalue, VIPS_TYPE_BLOB);
                    g_object_get_property(G_OBJECT(op), argument.name->c_str(), &gvalue);
                    vout = G_TYPE_CHECK_INSTANCE_CAST(g_value_get_object(&gvalue), VIPS_TYPE_BLOB, VipsBlob);
                    g_value_unset(&gvalue);
                    long *j = new long(id);
                    vout->area.client = j;
                    //@todo need a free function
                    void* outaddress =  (void *) vout;
                    if(unsafe) {
                        jobject o = env->CallStaticObjectMethod(javaLong.clazz, javaLong.factory, (jlong) outaddress);
                        env->SetObjectArrayElement(out, i + 2, o);
                    } else {
                        jobject  bb = env->NewDirectByteBuffer(outaddress, sizeof(VipsBlob));
                        env->SetObjectArrayElement(out, i + 2, bb);
                    }
                    break;
                }
                case jvips_VipsNative_VIPS_ARRAY_DOUBLE: {

                }
            }
        }


        vips_object_unref_outputs(VIPS_OBJECT(op));
        g_object_unref(op);


        return 1;
    }



/*
 * Class:     jvips_VipsNative
 * Method:    shutdown
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_jvips_VipsNative_shutdown
        (JNIEnv *env, jclass clazz) {


}

