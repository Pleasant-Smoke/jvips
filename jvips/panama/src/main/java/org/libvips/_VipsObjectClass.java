/*
 * jvips, a Java implementation that interfaces to libvips
 *
 * Copyright (C) 2023 Jonathan Strauss
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

// Generated by jextract

package org.libvips;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class _VipsObjectClass {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        MemoryLayout.structLayout(
            MemoryLayout.structLayout(
                Constants$root.C_LONG_LONG$LAYOUT.withName("g_type")
            ).withName("g_type_class"),
            Constants$root.C_POINTER$LAYOUT.withName("construct_properties"),
            Constants$root.C_POINTER$LAYOUT.withName("constructor"),
            Constants$root.C_POINTER$LAYOUT.withName("set_property"),
            Constants$root.C_POINTER$LAYOUT.withName("get_property"),
            Constants$root.C_POINTER$LAYOUT.withName("dispose"),
            Constants$root.C_POINTER$LAYOUT.withName("finalize"),
            Constants$root.C_POINTER$LAYOUT.withName("dispatch_properties_changed"),
            Constants$root.C_POINTER$LAYOUT.withName("notify"),
            Constants$root.C_POINTER$LAYOUT.withName("constructed"),
            Constants$root.C_LONG_LONG$LAYOUT.withName("flags"),
            Constants$root.C_LONG_LONG$LAYOUT.withName("n_construct_properties"),
            Constants$root.C_POINTER$LAYOUT.withName("pspecs"),
            Constants$root.C_LONG_LONG$LAYOUT.withName("n_pspecs"),
            MemoryLayout.sequenceLayout(3, Constants$root.C_POINTER$LAYOUT).withName("pdummy")
        ).withName("parent_class"),
        Constants$root.C_POINTER$LAYOUT.withName("build"),
        Constants$root.C_POINTER$LAYOUT.withName("postbuild"),
        Constants$root.C_POINTER$LAYOUT.withName("summary_class"),
        Constants$root.C_POINTER$LAYOUT.withName("summary"),
        Constants$root.C_POINTER$LAYOUT.withName("dump"),
        Constants$root.C_POINTER$LAYOUT.withName("sanity"),
        Constants$root.C_POINTER$LAYOUT.withName("rewind"),
        Constants$root.C_POINTER$LAYOUT.withName("preclose"),
        Constants$root.C_POINTER$LAYOUT.withName("close"),
        Constants$root.C_POINTER$LAYOUT.withName("postclose"),
        Constants$root.C_POINTER$LAYOUT.withName("new_from_string"),
        Constants$root.C_POINTER$LAYOUT.withName("to_string"),
        Constants$root.C_INT$LAYOUT.withName("output_needs_arg"),
        MemoryLayout.paddingLayout(32),
        Constants$root.C_POINTER$LAYOUT.withName("output_to_arg"),
        Constants$root.C_POINTER$LAYOUT.withName("nickname"),
        Constants$root.C_POINTER$LAYOUT.withName("description"),
        Constants$root.C_POINTER$LAYOUT.withName("argument_table"),
        Constants$root.C_POINTER$LAYOUT.withName("argument_table_traverse"),
        Constants$root.C_LONG_LONG$LAYOUT.withName("argument_table_traverse_gtype"),
        Constants$root.C_INT$LAYOUT.withName("deprecated"),
        MemoryLayout.paddingLayout(32),
        Constants$root.C_POINTER$LAYOUT.withName("_vips_reserved1"),
        Constants$root.C_POINTER$LAYOUT.withName("_vips_reserved2"),
        Constants$root.C_POINTER$LAYOUT.withName("_vips_reserved3"),
        Constants$root.C_POINTER$LAYOUT.withName("_vips_reserved4")
    ).withName("_VipsObjectClass");
    public static MemoryLayout $LAYOUT() {
        return _VipsObjectClass.$struct$LAYOUT;
    }
    public static MemorySegment parent_class$slice(MemorySegment seg) {
        return seg.asSlice(0, 136);
    }
    static final FunctionDescriptor build$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle build$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass.build$FUNC
    );
    public interface build {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(build fi, MemorySession session) {
            return RuntimeHelper.upcallStub(build.class, fi, _VipsObjectClass.build$FUNC, session);
        }
        static build ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)_VipsObjectClass.build$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle build$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("build"));
    public static VarHandle build$VH() {
        return _VipsObjectClass.build$VH;
    }
    public static MemoryAddress build$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.build$VH.get(seg);
    }
    public static void build$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.build$VH.set(seg, x);
    }
    public static MemoryAddress build$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.build$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void build$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.build$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static build build (MemorySegment segment, MemorySession session) {
        return build.ofAddress(build$get(segment), session);
    }
    static final FunctionDescriptor postbuild$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle postbuild$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass.postbuild$FUNC
    );
    public interface postbuild {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(postbuild fi, MemorySession session) {
            return RuntimeHelper.upcallStub(postbuild.class, fi, _VipsObjectClass.postbuild$FUNC, session);
        }
        static postbuild ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)_VipsObjectClass.postbuild$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle postbuild$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("postbuild"));
    public static VarHandle postbuild$VH() {
        return _VipsObjectClass.postbuild$VH;
    }
    public static MemoryAddress postbuild$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.postbuild$VH.get(seg);
    }
    public static void postbuild$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.postbuild$VH.set(seg, x);
    }
    public static MemoryAddress postbuild$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.postbuild$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void postbuild$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.postbuild$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static postbuild postbuild (MemorySegment segment, MemorySession session) {
        return postbuild.ofAddress(postbuild$get(segment), session);
    }
    static final FunctionDescriptor summary_class$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle summary_class$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass.summary_class$FUNC
    );
    public interface summary_class {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(summary_class fi, MemorySession session) {
            return RuntimeHelper.upcallStub(summary_class.class, fi, _VipsObjectClass.summary_class$FUNC, session);
        }
        static summary_class ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    _VipsObjectClass.summary_class$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle summary_class$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("summary_class"));
    public static VarHandle summary_class$VH() {
        return _VipsObjectClass.summary_class$VH;
    }
    public static MemoryAddress summary_class$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.summary_class$VH.get(seg);
    }
    public static void summary_class$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.summary_class$VH.set(seg, x);
    }
    public static MemoryAddress summary_class$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.summary_class$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void summary_class$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.summary_class$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static summary_class summary_class (MemorySegment segment, MemorySession session) {
        return summary_class.ofAddress(summary_class$get(segment), session);
    }
    static final FunctionDescriptor summary$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle summary$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass.summary$FUNC
    );
    public interface summary {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(summary fi, MemorySession session) {
            return RuntimeHelper.upcallStub(summary.class, fi, _VipsObjectClass.summary$FUNC, session);
        }
        static summary ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    _VipsObjectClass.summary$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle summary$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("summary"));
    public static VarHandle summary$VH() {
        return _VipsObjectClass.summary$VH;
    }
    public static MemoryAddress summary$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.summary$VH.get(seg);
    }
    public static void summary$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.summary$VH.set(seg, x);
    }
    public static MemoryAddress summary$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.summary$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void summary$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.summary$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static summary summary (MemorySegment segment, MemorySession session) {
        return summary.ofAddress(summary$get(segment), session);
    }
    static final FunctionDescriptor dump$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle dump$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass.dump$FUNC
    );
    public interface dump {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(dump fi, MemorySession session) {
            return RuntimeHelper.upcallStub(dump.class, fi, _VipsObjectClass.dump$FUNC, session);
        }
        static dump ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    _VipsObjectClass.dump$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle dump$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("dump"));
    public static VarHandle dump$VH() {
        return _VipsObjectClass.dump$VH;
    }
    public static MemoryAddress dump$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.dump$VH.get(seg);
    }
    public static void dump$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.dump$VH.set(seg, x);
    }
    public static MemoryAddress dump$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.dump$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void dump$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.dump$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static dump dump (MemorySegment segment, MemorySession session) {
        return dump.ofAddress(dump$get(segment), session);
    }
    static final FunctionDescriptor sanity$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle sanity$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass.sanity$FUNC
    );
    public interface sanity {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(sanity fi, MemorySession session) {
            return RuntimeHelper.upcallStub(sanity.class, fi, _VipsObjectClass.sanity$FUNC, session);
        }
        static sanity ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    _VipsObjectClass.sanity$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle sanity$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("sanity"));
    public static VarHandle sanity$VH() {
        return _VipsObjectClass.sanity$VH;
    }
    public static MemoryAddress sanity$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.sanity$VH.get(seg);
    }
    public static void sanity$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.sanity$VH.set(seg, x);
    }
    public static MemoryAddress sanity$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.sanity$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void sanity$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.sanity$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static sanity sanity (MemorySegment segment, MemorySession session) {
        return sanity.ofAddress(sanity$get(segment), session);
    }
    static final FunctionDescriptor rewind$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle rewind$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass.rewind$FUNC
    );
    public interface rewind {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(rewind fi, MemorySession session) {
            return RuntimeHelper.upcallStub(rewind.class, fi, _VipsObjectClass.rewind$FUNC, session);
        }
        static rewind ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    _VipsObjectClass.rewind$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle rewind$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("rewind"));
    public static VarHandle rewind$VH() {
        return _VipsObjectClass.rewind$VH;
    }
    public static MemoryAddress rewind$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.rewind$VH.get(seg);
    }
    public static void rewind$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.rewind$VH.set(seg, x);
    }
    public static MemoryAddress rewind$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.rewind$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void rewind$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.rewind$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static rewind rewind (MemorySegment segment, MemorySession session) {
        return rewind.ofAddress(rewind$get(segment), session);
    }
    static final FunctionDescriptor preclose$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle preclose$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass.preclose$FUNC
    );
    public interface preclose {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(preclose fi, MemorySession session) {
            return RuntimeHelper.upcallStub(preclose.class, fi, _VipsObjectClass.preclose$FUNC, session);
        }
        static preclose ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    _VipsObjectClass.preclose$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle preclose$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("preclose"));
    public static VarHandle preclose$VH() {
        return _VipsObjectClass.preclose$VH;
    }
    public static MemoryAddress preclose$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.preclose$VH.get(seg);
    }
    public static void preclose$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.preclose$VH.set(seg, x);
    }
    public static MemoryAddress preclose$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.preclose$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void preclose$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.preclose$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static preclose preclose (MemorySegment segment, MemorySession session) {
        return preclose.ofAddress(preclose$get(segment), session);
    }
    static final FunctionDescriptor close$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle close$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass.close$FUNC
    );
    public interface close {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(close fi, MemorySession session) {
            return RuntimeHelper.upcallStub(close.class, fi, _VipsObjectClass.close$FUNC, session);
        }
        static close ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    _VipsObjectClass.close$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle close$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("close"));
    public static VarHandle close$VH() {
        return _VipsObjectClass.close$VH;
    }
    public static MemoryAddress close$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.close$VH.get(seg);
    }
    public static void close$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.close$VH.set(seg, x);
    }
    public static MemoryAddress close$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.close$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void close$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.close$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static close close (MemorySegment segment, MemorySession session) {
        return close.ofAddress(close$get(segment), session);
    }
    static final FunctionDescriptor postclose$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle postclose$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass.postclose$FUNC
    );
    public interface postclose {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(postclose fi, MemorySession session) {
            return RuntimeHelper.upcallStub(postclose.class, fi, _VipsObjectClass.postclose$FUNC, session);
        }
        static postclose ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    _VipsObjectClass.postclose$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle postclose$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("postclose"));
    public static VarHandle postclose$VH() {
        return _VipsObjectClass.postclose$VH;
    }
    public static MemoryAddress postclose$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.postclose$VH.get(seg);
    }
    public static void postclose$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.postclose$VH.set(seg, x);
    }
    public static MemoryAddress postclose$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.postclose$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void postclose$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.postclose$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static postclose postclose (MemorySegment segment, MemorySession session) {
        return postclose.ofAddress(postclose$get(segment), session);
    }
    static final FunctionDescriptor new_from_string$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle new_from_string$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass.new_from_string$FUNC
    );
    public interface new_from_string {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(new_from_string fi, MemorySession session) {
            return RuntimeHelper.upcallStub(new_from_string.class, fi, _VipsObjectClass.new_from_string$FUNC, session);
        }
        static new_from_string ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)_VipsObjectClass.new_from_string$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle new_from_string$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("new_from_string"));
    public static VarHandle new_from_string$VH() {
        return _VipsObjectClass.new_from_string$VH;
    }
    public static MemoryAddress new_from_string$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.new_from_string$VH.get(seg);
    }
    public static void new_from_string$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.new_from_string$VH.set(seg, x);
    }
    public static MemoryAddress new_from_string$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.new_from_string$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void new_from_string$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.new_from_string$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static new_from_string new_from_string (MemorySegment segment, MemorySession session) {
        return new_from_string.ofAddress(new_from_string$get(segment), session);
    }
    static final FunctionDescriptor to_string$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle to_string$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass.to_string$FUNC
    );
    public interface to_string {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(to_string fi, MemorySession session) {
            return RuntimeHelper.upcallStub(to_string.class, fi, _VipsObjectClass.to_string$FUNC, session);
        }
        static to_string ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    _VipsObjectClass.to_string$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle to_string$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("to_string"));
    public static VarHandle to_string$VH() {
        return _VipsObjectClass.to_string$VH;
    }
    public static MemoryAddress to_string$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.to_string$VH.get(seg);
    }
    public static void to_string$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.to_string$VH.set(seg, x);
    }
    public static MemoryAddress to_string$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.to_string$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void to_string$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.to_string$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static to_string to_string (MemorySegment segment, MemorySession session) {
        return to_string.ofAddress(to_string$get(segment), session);
    }
    static final VarHandle output_needs_arg$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("output_needs_arg"));
    public static VarHandle output_needs_arg$VH() {
        return _VipsObjectClass.output_needs_arg$VH;
    }
    public static int output_needs_arg$get(MemorySegment seg) {
        return (int)_VipsObjectClass.output_needs_arg$VH.get(seg);
    }
    public static void output_needs_arg$set( MemorySegment seg, int x) {
        _VipsObjectClass.output_needs_arg$VH.set(seg, x);
    }
    public static int output_needs_arg$get(MemorySegment seg, long index) {
        return (int)_VipsObjectClass.output_needs_arg$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void output_needs_arg$set(MemorySegment seg, long index, int x) {
        _VipsObjectClass.output_needs_arg$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor output_to_arg$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle output_to_arg$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass.output_to_arg$FUNC
    );
    public interface output_to_arg {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(output_to_arg fi, MemorySession session) {
            return RuntimeHelper.upcallStub(output_to_arg.class, fi, _VipsObjectClass.output_to_arg$FUNC, session);
        }
        static output_to_arg ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)_VipsObjectClass.output_to_arg$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle output_to_arg$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("output_to_arg"));
    public static VarHandle output_to_arg$VH() {
        return _VipsObjectClass.output_to_arg$VH;
    }
    public static MemoryAddress output_to_arg$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.output_to_arg$VH.get(seg);
    }
    public static void output_to_arg$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.output_to_arg$VH.set(seg, x);
    }
    public static MemoryAddress output_to_arg$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.output_to_arg$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void output_to_arg$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.output_to_arg$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static output_to_arg output_to_arg (MemorySegment segment, MemorySession session) {
        return output_to_arg.ofAddress(output_to_arg$get(segment), session);
    }
    static final VarHandle nickname$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("nickname"));
    public static VarHandle nickname$VH() {
        return _VipsObjectClass.nickname$VH;
    }
    public static MemoryAddress nickname$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.nickname$VH.get(seg);
    }
    public static void nickname$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.nickname$VH.set(seg, x);
    }
    public static MemoryAddress nickname$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.nickname$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void nickname$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.nickname$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle description$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("description"));
    public static VarHandle description$VH() {
        return _VipsObjectClass.description$VH;
    }
    public static MemoryAddress description$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.description$VH.get(seg);
    }
    public static void description$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.description$VH.set(seg, x);
    }
    public static MemoryAddress description$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.description$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void description$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.description$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle argument_table$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("argument_table"));
    public static VarHandle argument_table$VH() {
        return _VipsObjectClass.argument_table$VH;
    }
    public static MemoryAddress argument_table$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.argument_table$VH.get(seg);
    }
    public static void argument_table$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.argument_table$VH.set(seg, x);
    }
    public static MemoryAddress argument_table$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.argument_table$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void argument_table$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.argument_table$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle argument_table_traverse$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("argument_table_traverse"));
    public static VarHandle argument_table_traverse$VH() {
        return _VipsObjectClass.argument_table_traverse$VH;
    }
    public static MemoryAddress argument_table_traverse$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.argument_table_traverse$VH.get(seg);
    }
    public static void argument_table_traverse$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass.argument_table_traverse$VH.set(seg, x);
    }
    public static MemoryAddress argument_table_traverse$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass.argument_table_traverse$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void argument_table_traverse$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass.argument_table_traverse$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle argument_table_traverse_gtype$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("argument_table_traverse_gtype"));
    public static VarHandle argument_table_traverse_gtype$VH() {
        return _VipsObjectClass.argument_table_traverse_gtype$VH;
    }
    public static long argument_table_traverse_gtype$get(MemorySegment seg) {
        return (long)_VipsObjectClass.argument_table_traverse_gtype$VH.get(seg);
    }
    public static void argument_table_traverse_gtype$set( MemorySegment seg, long x) {
        _VipsObjectClass.argument_table_traverse_gtype$VH.set(seg, x);
    }
    public static long argument_table_traverse_gtype$get(MemorySegment seg, long index) {
        return (long)_VipsObjectClass.argument_table_traverse_gtype$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void argument_table_traverse_gtype$set(MemorySegment seg, long index, long x) {
        _VipsObjectClass.argument_table_traverse_gtype$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle deprecated$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("deprecated"));
    public static VarHandle deprecated$VH() {
        return _VipsObjectClass.deprecated$VH;
    }
    public static int deprecated$get(MemorySegment seg) {
        return (int)_VipsObjectClass.deprecated$VH.get(seg);
    }
    public static void deprecated$set( MemorySegment seg, int x) {
        _VipsObjectClass.deprecated$VH.set(seg, x);
    }
    public static int deprecated$get(MemorySegment seg, long index) {
        return (int)_VipsObjectClass.deprecated$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void deprecated$set(MemorySegment seg, long index, int x) {
        _VipsObjectClass.deprecated$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor _vips_reserved1$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _vips_reserved1$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass._vips_reserved1$FUNC
    );
    public interface _vips_reserved1 {

        void apply();
        static MemorySegment allocate(_vips_reserved1 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_vips_reserved1.class, fi, _VipsObjectClass._vips_reserved1$FUNC, session);
        }
        static _vips_reserved1 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _VipsObjectClass._vips_reserved1$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _vips_reserved1$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_vips_reserved1"));
    public static VarHandle _vips_reserved1$VH() {
        return _VipsObjectClass._vips_reserved1$VH;
    }
    public static MemoryAddress _vips_reserved1$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass._vips_reserved1$VH.get(seg);
    }
    public static void _vips_reserved1$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass._vips_reserved1$VH.set(seg, x);
    }
    public static MemoryAddress _vips_reserved1$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass._vips_reserved1$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _vips_reserved1$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass._vips_reserved1$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _vips_reserved1 _vips_reserved1 (MemorySegment segment, MemorySession session) {
        return _vips_reserved1.ofAddress(_vips_reserved1$get(segment), session);
    }
    static final FunctionDescriptor _vips_reserved2$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _vips_reserved2$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass._vips_reserved2$FUNC
    );
    public interface _vips_reserved2 {

        void apply();
        static MemorySegment allocate(_vips_reserved2 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_vips_reserved2.class, fi, _VipsObjectClass._vips_reserved2$FUNC, session);
        }
        static _vips_reserved2 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _VipsObjectClass._vips_reserved2$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _vips_reserved2$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_vips_reserved2"));
    public static VarHandle _vips_reserved2$VH() {
        return _VipsObjectClass._vips_reserved2$VH;
    }
    public static MemoryAddress _vips_reserved2$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass._vips_reserved2$VH.get(seg);
    }
    public static void _vips_reserved2$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass._vips_reserved2$VH.set(seg, x);
    }
    public static MemoryAddress _vips_reserved2$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass._vips_reserved2$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _vips_reserved2$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass._vips_reserved2$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _vips_reserved2 _vips_reserved2 (MemorySegment segment, MemorySession session) {
        return _vips_reserved2.ofAddress(_vips_reserved2$get(segment), session);
    }
    static final FunctionDescriptor _vips_reserved3$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _vips_reserved3$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass._vips_reserved3$FUNC
    );
    public interface _vips_reserved3 {

        void apply();
        static MemorySegment allocate(_vips_reserved3 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_vips_reserved3.class, fi, _VipsObjectClass._vips_reserved3$FUNC, session);
        }
        static _vips_reserved3 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _VipsObjectClass._vips_reserved3$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _vips_reserved3$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_vips_reserved3"));
    public static VarHandle _vips_reserved3$VH() {
        return _VipsObjectClass._vips_reserved3$VH;
    }
    public static MemoryAddress _vips_reserved3$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass._vips_reserved3$VH.get(seg);
    }
    public static void _vips_reserved3$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass._vips_reserved3$VH.set(seg, x);
    }
    public static MemoryAddress _vips_reserved3$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass._vips_reserved3$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _vips_reserved3$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass._vips_reserved3$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _vips_reserved3 _vips_reserved3 (MemorySegment segment, MemorySession session) {
        return _vips_reserved3.ofAddress(_vips_reserved3$get(segment), session);
    }
    static final FunctionDescriptor _vips_reserved4$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle _vips_reserved4$MH = RuntimeHelper.downcallHandle(
        _VipsObjectClass._vips_reserved4$FUNC
    );
    public interface _vips_reserved4 {

        void apply();
        static MemorySegment allocate(_vips_reserved4 fi, MemorySession session) {
            return RuntimeHelper.upcallStub(_vips_reserved4.class, fi, _VipsObjectClass._vips_reserved4$FUNC, session);
        }
        static _vips_reserved4 ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return () -> {
                try {
                    _VipsObjectClass._vips_reserved4$MH.invokeExact((Addressable)symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle _vips_reserved4$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("_vips_reserved4"));
    public static VarHandle _vips_reserved4$VH() {
        return _VipsObjectClass._vips_reserved4$VH;
    }
    public static MemoryAddress _vips_reserved4$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass._vips_reserved4$VH.get(seg);
    }
    public static void _vips_reserved4$set( MemorySegment seg, MemoryAddress x) {
        _VipsObjectClass._vips_reserved4$VH.set(seg, x);
    }
    public static MemoryAddress _vips_reserved4$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)_VipsObjectClass._vips_reserved4$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void _vips_reserved4$set(MemorySegment seg, long index, MemoryAddress x) {
        _VipsObjectClass._vips_reserved4$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static _vips_reserved4 _vips_reserved4 (MemorySegment segment, MemorySession session) {
        return _vips_reserved4.ofAddress(_vips_reserved4$get(segment), session);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


